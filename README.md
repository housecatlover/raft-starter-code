Plan:
Our plan followed the suggested order of operations outline detailed on the project page. We added basic support for responding to client get() and put() requests so that we could have an outline for how we responded to requests. Then, we implemented the election protocol which included the timeouts and the voting logic. After doing so, we could then implement the AppendEntries RPC which we planned to make more robust with more testing done. After this point, we implemented failure detection which would help our code run smoothly. Working with the nuances and the edge cases was something that we planned to do as part of our testing phase where we could see the results and debug the code according to what we expected the output to be.

Features:
A feature we would like to highlight is the update_followers. update_followers simplified the need for batching by sending the entire log from the most recent known matching index, this meant that every heartbeat would be able to send the last batch or we could trigger it at any condition. This allowed us to easily consider updating when the number of pending entries got too long or when receiving every put. Next, last_consensus lets us keep track of whether the leader was receiving feedback from a majority of followers, allowing us to identify partitions or bugs from the leader no longer being fit.

Challenges:
The main challenge that we faced was balancing optimizing performance. We found that the performance of our code varied based on the different parameters we could tweak such as the heartbeats and the timeouts. The challenge came when trying to get the performance to be perfect as there were tradeoffs we had to make, at least in our initial testing phase. Additionally, another aspect we found challenging was implementing induction. When implementing induction, we found the biggest challenge to be creating the most efficient method of induction we could. We tried different approaches which had tradeoffs with correctness and performance but we were able to dial it down in the end and make induction work smoothly.

Testing Approach:
Our testing approach was to gradually test parts of the programs and build on what we had so far after adjusting based on the results of each test. We initially began with getting the basic processes to work in the milestone which helped us establish a connection and build on the features. After we ensured that the basic functionality worked, we began testing processes raft is expected to carry out such as the consensus protocol. 
