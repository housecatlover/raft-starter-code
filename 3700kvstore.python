#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random

BROADCAST = "FFFF"
TIMEOUT = .03  # TODO this is just a guess
HEARTBEAT = TIMEOUT / 2  # how often heartbeats should be sent

State = Enum('State', [FOLLOWER, CANDIDATE, LEADER])


class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others

        self.time_since_heartbeat = 0  # for the follower's this can be time since having heard
        self.timeout = random.randRange(TIMEOUT, TIMEOUT * 2)  # recalc on each timeout

        self.currentTerm = 0
        self.leader = 'FFFF'  # start as unknown

        self.log = []  # pair <term, command>

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        print("Replica %s starting up" % self.id, flush=True)
        hello = {"src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello"}
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    # if dst is set to "FFFF", the message will be delivered to all replicas (use multicast sparingly, since it is expensive)
    def send(self, message):
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def fail(self, msg):
        self.send({"src": self.id, "dst": msg['src'], "leader": self.leader,
                   "type": "fail", "MID": msg['MID']})
    
    def ok(self, msg):
        self.send({"src": self.id, "dst": msg['src'], "leader": self.leader,
                   "type": "ok", "MID": msg['MID']})

    def redirect(self, msg):
        if self.leader != self.id:
            self.send({"src": self.id, "dst": msg['src'], "leader": self.leader,
                       "type": "redirect", "MID": msg['MID']})
            return true
        return false

    def getRequest(self, msg):
        self.fail(msg)

    def setRequest(self, msg):
        self.fail(msg)

    def run(self):
        while True:
            select.select([self.socket], [], [])  # TODO added, blocks till recv
            data, addr = self.socket.recvfrom(65535)
            msg = data.decode('utf-8')
            print("Received message '%s'" % (msg,), flush=True)

            # TODO added from here
            msg = json.loads(msg)
            if msg['type'] == 'get':
                if redirect(msg):
                    continue
                getRequest(msg)  # will have a MID and a key to be gotten
            elif msg['type'] == 'set':
                if redirect(msg):
                    continue
                setRequest(msg)
            #  elif msg['type'] == 'something from another replica'


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
