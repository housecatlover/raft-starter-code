#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random, secrets
# secrets.token_hex(16)
BROADCAST = "FFFF"
TIMEOUT = 2.5
HEARTBEAT = TIMEOUT / 2  # how often heartbeats should be sent

TERM = 0
COMMAND = 1

class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others

        self.last_heartbeat = time.time()  # for the follower's this can be time since having heard
        self.timeout = TIMEOUT * (random.random() + 1)  # recalculate on each timeout

        self.currentTerm = 0
        self.leader = 'FFFF'  # start as unknown
        self.status = 'follower'

        self.votedFor = None
        self.num_votes = 0

        self.log = []  # pair <term, command> as defined in the constants
        self.data = {}
        self.lastApplied = 0
        self.pending = {}  # 'MID' : (msg, numVotes)
        self.events = []  # time : 'MID' the first will always expire first

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        print("Replica %s starting up" % self.id, flush=True)
        hello = {"src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello"}
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def send(self, message):
        if message['type'] == 'AppendEntries' and message['dst'] == BROADCAST:
            self.last_heartbeat = time.time()
        print("Sending message message '%s'" % (message,), flush=True)
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def send_args(self, dst, type, MID, term, value):
        message = {"src": self.id, "dst": dst, "leader": self.leader,
                   "type": type}
        if MID is not None:
            message['MID'] = MID
        if term is not None:
            message['term'] = term
        if value is not None:
            message['value'] = value
        self.send(message)

    def send_append(self, dst, MID, prevLogIndex, prevLogTerm, entries):
        self.send({"src": self.id, "dst": BROADCAST if dst is None else dst, "leader": self.leader,
                   "type": 'AppendEntries', 'MID': MID, 'term': self.currentTerm,
                   'prevLogIndex': prevLogIndex, 'prevLogTerm': prevLogTerm,
                   'entries': entries, 'leaderCommit': None})  # TODO figure out what commit means

    def fail(self, msg):
        self.send_args(msg['src'], 'fail', msg['MID'], None, None)

    def ok(self, msg, value):
        self.send_args(msg['src'], 'ok', msg['MID'], None, value)

    def redirect(self, msg):
        if self.leader is None:
            self.fail(msg)
        if self.leader != self.id:
            self.send_args(msg['src'], 'redirect', msg['MID'], None, None)
            return True
        return False

    def get_request(self, msg):
        contents = self.data.get(msg['key'])
        value = '' if contents is None else contents[-1]
        if self.status == 'leader':
            self.ok(msg, value)

    def put_request(self, msg):
        if self.status == 'leader':
            entry = (self.currentTerm, (msg['key'], msg['value']))
            self.send_append(None, msg['MID'], self.commitIndex(), self.lastTerm(), [entry])
            self.log.append(entry)
            self.pending[msg['MID']] = {'msg': msg, 'vote_count': 0}

    def apply_put(self, msg):
        current = self.data.get(msg['key'])
        if current is None:
            current = [msg['value']]
        else:
            current.append(msg['value'])
        self.data[msg['key']] = current
        self.ok(msg, None)

    def commitIndex(self):
        return len(self.log) - 1

    def lastTerm(self):
        return self.log[-1][TERM] if len(self.log) > 0 else 0

    def elect(self):
        self.currentTerm += 1
        self.status = 'candidate'
        self.votedFor = self.id
        self.num_votes = 0
        self.send({'src': self.id, 'dst': BROADCAST, 'leader': self.leader, 'type': 'candidacy',
                   'lastTerm': self.lastTerm(), 'lastIndex': len(self.log), 'term': self.currentTerm})

    def vote(self, msg):
        if msg['term'] < self.currentTerm:
            return  # False
        if self.votedFor is None or self.votedFor == msg['src']:
            if msg['lastTerm'] >= self.lastTerm():
                self.votedFor = msg['src']
                self.send_args(msg['src'], 'vote', None, self.currentTerm, None)
                self.last_heartbeat = time.time()
                return

    def forget(self, MID):
        self.pending.pop(MID)
        for i in range(len(self.events)):
            if self.events[i][0] == MID:
                self.events.pop()
                break

    def consider_append(self, msg):
        if self.log[msg['prevLogIndex']][TERM] == msg['prevLogTerm']:
            for i in range(len(self.log) - 1 - msg['prevLogIndex']):
                self.log.pop(len(self.log) - 1)
            self.log.extend(msg['entries'])
            self.send_args(self.leader, 'agree', msg['MID'], self.currentTerm, self.commitIndex())
        else:
            self.send_args(self.leader, 'induce_me', msg['MID'], None, self.log)

    def induce(self, msg):
        for index in range(len(msg['value'])):
            if msg['value'][index] != self.log[index]:
                self.send_append(msg['src'], msg['MID'], index - 1, self.log[index - 1][TERM],
                                 self.log[index:])

    def run(self):
        while True:
            ready = select.select([self.socket], [], [], .01)[0]
            if len(ready) == 1:
                data, addr = self.socket.recvfrom(65535)
                msg = json.loads(data.decode('utf-8'))
                print("Received message '%s'" % (msg,), flush=True)

                term = msg.get('term')
                if term is not None and term > self.currentTerm:
                    self.currentTerm = term
                    self.votedFor = None
                    self.status = 'follower'

                if msg['src'] == self.leader:
                    self.last_heartbeat = time.time()

                if msg['dst'] != self.id and msg['dst'] != BROADCAST:
                    print('Sent to the wrong host', flush=True)
                    continue

                if msg['type'] == 'get':
                    if self.redirect(msg):
                        continue
                    self.get_request(msg)  # will have a MID and a key to be gotten
                elif msg['type'] == 'put':
                    if self.redirect(msg):
                        continue
                    self.put_request(msg)

                if self.status == 'leader':
                    if msg['type'] == 'agree':
                        target = self.pending.get(msg['MID'])
                        if target is not None:
                            # TODO can also intuit votes on log entries less then self.commitIndex()
                            # TODO found in the message's value field
                            target['vote_count'] += 1  # increment the votes on the targeted pending message
                            if target['vote_count'] > int(len(self.others) / 2):
                                self.apply_put(target['msg'])
                                self.forget(msg['MID'])
                    elif msg['type'] == 'induce_me':
                        self.induce(msg)

                if self.status == 'candidate':
                    if msg['type'] == 'vote' and msg['term'] == self.currentTerm:
                        self.num_votes += 1
                        if self.num_votes >= len(self.others) / 2:
                            self.status = 'leader'
                            self.leader = self.id
                            # other leader things
                    elif msg['type'] == 'AppendEntries':
                        if msg['leader'] != self.leader:
                            self.status = 'follower'
                            self.leader = msg['leader']

                if self.status == 'follower':
                    if msg['type'] == 'candidacy':
                        self.vote(msg)
                    elif msg['type'] == 'consider':
                        if msg['value']['type'] == 'get':
                            self.get_request(msg['value'])  # will have a MID and a key to be gotten
                        else:
                            self.put_request(msg['value'])
                    elif msg['type'] == 'AppendEntries':
                        self.consider_append(msg)

            # back to running every tick
            currentTime = time.time()
            if self.status != 'leader' and \
                    currentTime - self.last_heartbeat > self.timeout:
                print(currentTime - self.last_heartbeat)
                self.last_heartbeat = currentTime
                self.timeout = TIMEOUT * (random.random() + 1)  # 1-2 x timeout
                self.elect()
                continue

            if self.status == 'leader' and \
                    currentTime - self.last_heartbeat > HEARTBEAT:
                self.last_heartbeat = currentTime
                self.send_args(BROADCAST, 'AppendEntries', None, self.currentTerm, None)  # Heartbeat


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
