#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random, secrets

# secrets.token_hex(16)
BROADCAST = "FFFF"
TIMEOUT = .2
HEARTBEAT = TIMEOUT / 2  # how often heartbeats should be sent
LEADER_TIMEOUT = TIMEOUT * 2

TERM = 0
ENTRY = 1


class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others

        self.last_heartbeat = time.time()  # for the follower's this can be time since having heard
        self.timeout = TIMEOUT * (random.random() + 1)  # recalculate on each timeout
        self.last_consensus = time.time()

        self.currentTerm = 0
        self.leader = 'FFFF'  # start as unknown
        self.status = 'follower'

        self.votedFor = None
        self.num_votes = set()  # todo refactor to votes

        self.log = []  # pair <term, <key, value>> as defined in the constants
        self.data = {}  # the key, value dict that is the store
        self.lastApplied = -1
        self.pending = {}  # 'MID' : {'msg': msg, 'numVotes': set(votes), 'index': the index it is given in the log}

        self.commitIndex = -1  # the last know index to be committed to the leader's log (got consensus)
        self.matchIndex = {}  # id: max known index

        self.redirect_queue = []  # all of the messages this replica has to redirect
        self.redirect_timeout = time.time()  # the time of the last redirection batch

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        # ("Replica %s starting up" % self.id, flush=True)
        hello = {"src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello"}
        self.send(hello)
        # print("Sent hello message: %s" % hello, flush=True)

    def send(self, message):
        # print('sending ' + str(message))
        # if message['type'] == 'AppendEntries' and message['dst'] == BROADCAST:
        #     self.last_heartbeat = time.time()
        # print("Sending message message '%s'" % (message,), flush=True)
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def send_args(self, dst, type, MID, term, value):
        message = {"src": self.id, "dst": dst, "leader": self.leader,
                   "type": type}
        if MID is not None:
            message['MID'] = MID
        if term is not None:
            message['term'] = term
        if value is not None:
            message['value'] = value
        self.send(message)

    def send_append(self, dst, MID, prevLogIndex, prevLogTerm, entries):
        message = {"src": self.id, "dst": BROADCAST if dst is None else dst, "leader": self.leader,
                   "type": 'AppendEntries', 'term': self.currentTerm,
                   'prevLogIndex': prevLogIndex, 'prevLogTerm': prevLogTerm,
                   'entries': entries, 'leaderCommit': self.lastApplied}
        if MID is not None:
            message['MID'] = MID
        self.send(message)

    def fail(self, msg):
        #print('failing ' + msg['MID'], flush=True)
        self.send_args(msg['src'], 'fail', msg['MID'], None, None)

    def ok(self, msg, value):
        #print('oking ' + str(msg), flush=True)
        self.send_args(msg['src'], 'ok', msg['MID'], None, value)

    def send_redirect(self, msg):
        self.send_args(msg['src'], 'redirect', msg['MID'], None, None)

    def redirect(self, msg):
        if self.leader is None:
            self.fail(msg)
        if self.status != 'leader':
            self.redirect_queue.append(msg)
            return True
        return False

    def get_request(self, msg):
        contents = self.data.get(msg['key'])
        value = '' if contents is None else contents
        self.ok(msg, value)

    def put_request(self, msg):
        # print('got put request ' + msg['MID'], flush=True)
        if msg['MID'] in self.pending:
            #print('duplicate request', flush=True)
            return
        if self.status == 'leader':  # no duplicate
            entry = (self.currentTerm, (msg['key'], msg['value']))
            # self.send_append(None, msg['MID'], self.prevIndex(), self.prevTerm(), [entry])
            self.log.append(entry)
            self.pending[msg['MID']] = {'msg': msg, 'index': self.prevIndex()}

    def apply_put(self, msg):
        self.apply_log()
        self.commitIndex = self.lastApplied  # only called for the leader
        self.ok(msg, None)

    def apply_log(self):
        self.lastApplied += 1
        key, value = self.log[self.lastApplied][ENTRY]
        # print('applying ' + key + value, flush=True)
        self.data[key] = value

    def prevIndex(self):
        return len(self.log) - 1

    def prevTerm(self):
        return self.log[-1][TERM] if len(self.log) > 0 else 0

    def elect(self):
        #print('vote for me')
        self.currentTerm += 1
        self.status = 'candidate'
        self.leader = BROADCAST
        self.votedFor = self.id
        self.num_votes = set()
        self.send({'src': self.id, 'dst': BROADCAST, 'leader': self.leader, 'type': 'candidacy',
                   'lastTerm': self.prevTerm(), 'lastIndex': self.prevIndex(), 'term': self.currentTerm})

    def vote(self, msg):
        if msg['term'] < self.currentTerm:
            return  # False
        if self.votedFor is None or self.votedFor == msg['src']:
            if msg['lastTerm'] > self.prevTerm() or \
                    (msg['lastTerm'] == self.prevTerm() and msg['lastIndex'] >= self.prevIndex()):
                self.votedFor = msg['src']
                self.send_args(msg['src'], 'vote', None, self.currentTerm, None)
                self.last_heartbeat = time.time()
                return
        #print('voting against' + msg['src'])


    def consider_append(self, msg):
        if len(msg['entries']) == 0:  # if it is a heartbeat
            if msg['leaderCommit'] >= len(self.log):
                self.send_args(self.leader, 'induce_me', msg.get('MID'), None, self.commitIndex)
            return
        prev_i = msg['prevLogIndex']
        if len(self.log) > prev_i + 1 and self.log[prev_i + 1:] == msg['entries']:
            # print('was skipping the application of append since it was already there')
            self.send_args(self.leader, 'agree', msg.get('MID'), self.currentTerm, self.prevIndex())
            return  # already applied, probably duplicate message
        if prev_i == -1 \
                or (len(self.log) > msg['prevLogIndex']  # if index is in the log
                    and self.log[prev_i][TERM] == msg['prevLogTerm']):
            for i in range(len(self.log) - 1 - prev_i):
                self.log.pop(len(self.log) - 1)
            self.log.extend(msg['entries'])
            self.send_args(self.leader, 'agree', msg.get('MID'), self.currentTerm, self.prevIndex())
            if msg['leaderCommit'] > self.commitIndex:
                self.commitIndex = min(msg['leaderCommit'], self.prevIndex())
                while self.commitIndex > self.lastApplied:
                    self.apply_log()
        else:
            self.send_args(self.leader, 'induce_me', msg.get('MID'), None, self.commitIndex)

    def induce(self, msg):
        index = self.matchIndex.get(msg['src'])
        if index is None:
            index = msg['value']  # if it's an induce me request
        self.induce_from(msg.get('MID'), index, msg['src'])

    def update_followers(self):
        for follower in self.others:
            index = self.matchIndex.get(follower)  # send append from the earliest known index
            if index is None:
                index = max(len(self.log) - 50, 0)
            self.induce_from(None, index, follower)

    def induce_from(self, MID, index, dst):
        if index >= len(self.log):
            #print('tried to induce starting after the leaders log ' + str(index) + ' > ' + str(len(self.log)))
            return
        if len(self.log) - index < 51:
            self.send_append(dst, MID, index, self.log[index][TERM], self.log[index + 1:])
        else:
            self.send_append(dst, MID, index, self.log[index][TERM], self.log[index + 1:index + 51])
            self.induce_from(MID, index + 50, dst)


    def deprecated_induce(self, msg):
        log_len = len(msg['value'])
        for index in range(min(log_len, len(self.log)) - 1, -1, -1):
            if msg['value'][index] == self.log[index]:  # if the value is the same at this index
                if len(self.log) <= index + 1:  # then, if the leader's log is not longer
                    return  # nothing to append: exit
                self.send_append(msg['src'], msg['MID'], index, self.log[index][TERM],
                                 self.log[index + 1:])  # if the leader's log is longer, fill in the follower's log
                return  # we found the common point of agreement and replaced the follower's log accordingly so exit
        # otherwise, no point of agreement, replace follower's log
        self.send_append(msg['src'], msg['MID'], -1, 0, self.log)

    def resolve_log(self):
        remove = set()
        for MID in self.pending.keys():
            msg = self.pending[MID]['msg']
            self.redirect(msg)
            # self.fail(msg)
        self.pending = {}

    def highest_concensus(self):
        indices = []
        for index in self.matchIndex.values():
            indices.append(index)
        indices.append(len(self.log) + 1)
        sorted(indices)
        if len(indices) > 2:
            return indices[-3]
        return self.commitIndex

    def leader_recv(self, msg):
        if msg['type'] == 'agree':

            # update matchIndex
            current = self.matchIndex.get(msg['src'])
            if current is None:
                current = -1
            self.matchIndex[msg['src']] = max(msg['value'], current)

            highest_consensus = self.highest_concensus()

            while self.lastApplied < highest_consensus:
                self.apply_log()
            self.commitIndex = self.lastApplied

            done = set()
            for MID in self.pending.keys():
                entry = self.pending[MID]
                if entry['index'] <= self.commitIndex:
                    self.ok(entry['msg'], None)
                    done.add(MID)
            for MID in done:
                self.pending.pop(MID)
            if len(done) > 0:
                self.last_consensus = time.time()

        elif msg['type'] == 'induce_me':
            self.induce(msg)

    def candidate_recv(self, msg):
        if msg['type'] == 'vote' and msg['term'] == self.currentTerm:
            self.num_votes.add(msg['src'])
            #print('votes: ' + str(self.num_votes) + ' term: ' + str(self.currentTerm))
            if len(self.num_votes) >= len(self.others) / 2:
              #(str(len(self.num_votes)) + '>=' + str(len(self.others) / 2))
                self.status = 'leader'
                self.leader = self.id
                self.last_consensus = time.time()
                # the log is retained as it is still the leader
                # other leader things
        elif msg['type'] == 'AppendEntries':
            if msg['leader'] != self.leader and msg['term'] >= self.currentTerm:
                self.status = 'follower'
                self.leader = msg['leader']
                self.resolve_log()

    def follower_recv(self, msg):
        if msg['type'] == 'candidacy':
            self.vote(msg)
        elif msg['type'] == 'consider':
            if msg['value']['type'] == 'get':
                self.get_request(msg['value'])  # will have a MID and a key to be gotten
            else:
                self.put_request(msg['value'])
        elif msg['type'] == 'AppendEntries':
            if msg['leader'] != self.leader and msg['term'] >= self.currentTerm:
                self.leader = msg['leader']
                self.resolve_log()
            self.consider_append(msg)

    def leader_heartbeat(self):
        #print(str(self.matchIndex) + ' leader commit: ' + str(self.lastApplied) + \
              #' leader len: ' + str(len(self.log)) + ' pending: ' + str(len(self.pending)), flush=True)
        # if len(self.pending) > 0:
            #print('number pending ' + str(len(self.pending)))
        if time.time() - self.last_heartbeat > HEARTBEAT:
            self.last_heartbeat = time.time()
            #self.send_append(None, '', self.prevIndex(), self.prevTerm(), [])
            self.update_followers()

        if time.time() - self.last_consensus > LEADER_TIMEOUT:
            #print("consensus timed out, see if I'm still the leader")
            self.last_heartbeat = time.time()
            self.timeout = TIMEOUT * (random.random() + 1)
            self.elect()

    def election_heartbeat(self):
        if self.status != 'leader' and \
                time.time() - self.last_heartbeat > self.timeout:
            #print('I SHOULD TIMEOUT')
            self.last_heartbeat = time.time()
            self.timeout = TIMEOUT * (random.random() + 1)  # +1 for fewer leader tieouts 1-2 x timeout
            self.elect()
            return True
        return False

    def run(self):
        while True:
            ready = select.select([self.socket], [], [], .01)[0]
            if len(ready) == 1:
                data, addr = self.socket.recvfrom(65535)
                msg = json.loads(data.decode('utf-8'))
                #print("Received message '%s'" % (msg,), flush=True)

                term = msg.get('term')
                if term is not None and term > self.currentTerm:
                    self.currentTerm = term
                    self.votedFor = None
                    self.status = 'follower'

                if msg['src'] == self.leader:
                    self.last_heartbeat = time.time()

                if msg['dst'] != self.id and msg['dst'] != BROADCAST:
                    #print('Sent to the wrong host', flush=True)
                    continue

                if msg['type'] == 'get':
                    # print('received get', flush=True)
                    if self.redirect(msg):
                        continue
                    self.get_request(msg)  # will have a MID and a key to be gotten
                elif msg['type'] == 'put':
                    # print('received put', flush=True)
                    if self.redirect(msg):
                        continue
                    self.put_request(msg)

                if self.status == 'leader':
                    self.leader_recv(msg)

                if self.status == 'candidate':
                    self.candidate_recv(msg)

                if self.status == 'follower':
                    self.follower_recv(msg)

            # back to running every tick
            if self.election_heartbeat():
                continue

            current_time = time.time()
            if current_time - self.redirect_timeout > TIMEOUT:
                while len(self.redirect_queue) != 0:
                    self.send_redirect(self.redirect_queue.pop())
                self.redirect_timeout = current_time

            if self.status == 'leader':
                self.leader_heartbeat()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()