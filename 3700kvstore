#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random

BROADCAST = "FFFF"
TIMEOUT = .3  # TODO this is just a guess
HEARTBEAT = TIMEOUT / 2  # how often heartbeats should be sent


class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others

        self.last_heartbeat = time.time()  # for the follower's this can be time since having heard
        self.timeout = TIMEOUT * (random.random() + 1)  # recalc on each timeout

        self.currentTerm = 0
        self.leader = 'FFFF'  # start as unknown
        self.status = 'follower'

        self.votedFor = None
        self.num_votes = 0

        self.log = []  # pair <term, command>
        self.data = {}

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        print("Replica %s starting up" % self.id, flush=True)
        hello = {"src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello"}
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    # if dst is set to "FFFF", the message will be delivered to all replicas (use multicast sparingly, since it is expensive)
    def send(self, message):
        print("Sending message message '%s'" % (message,), flush=True)
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def send_args(self, dst, type, MID, term, value):
        message = {"src": self.id, "dst": dst, "leader": self.leader,
                   "type": type}
        if MID is not None:
            message['MID'] = MID
        if term is not None:
            message['term'] = term
        if value is not None:
            message['value'] = value
        self.send(message)

    def fail(self, msg):
        self.send_args(msg['src'], 'fail', msg['MID'], None, None)

    def ok(self, msg, value):
        self.send_args(msg['src'], 'ok', msg['MID'], None, value)

    def redirect(self, msg):
        if self.leader is None:
            self.fail(msg)
        if self.leader != self.id:
            self.send_args(msg['src'], 'redirect', msg['MID'], None, None)
            return True
        return False

    def getRequest(self, msg):
        # I am the leader
        contents = self.data.get(msg['key'])
        value = '' if contents is None else contents[-1]
        self.ok(msg, value)

    def setRequest(self, msg):
        #  I am the leader
        self.log.append((self.currentTerm, (msg['key'], msg['value'])))
        current = self.data.get(msg['key'])
        if current is None:
            current = [msg['value']]
        else:
            current.append(msg['value'])
        self.data[msg['key']] = current
        self.ok(msg, None)

    def lastTerm(self):
        return self.log[-1].term if len(self.log) > 0 else 0

    def elect(self):
        self.currentTerm += 1
        self.status = 'candidate'
        self.votedFor = self.id
        self.num_votes = 0
        self.send({'src': self.id, 'dst': BROADCAST, 'leader': self.leader, 'type': 'candidacy',
                   'lastTerm': self.lastTerm(), 'lastIndex': len(self.log), 'term': self.currentTerm})

    def vote(self, msg):
        if msg['term'] < self.currentTerm:
            return  # False
        if self.votedFor is None or self.votedFor == msg['src']:
            if msg['lastTerm'] >= self.lastTerm():
                self.votedFor = msg['src']
                self.send_args(msg['src'], 'vote', None, None, None)
                self.last_heartbeat = time.time()  # TODO added
                return

    def run(self):
        while True:
            ready = select.select([self.socket], [], [], .01)[0]
            if len(ready) == 1:
                data, addr = self.socket.recvfrom(65535)
                msg = json.loads(data.decode('utf-8'))
                print("Received message '%s'" % (msg,), flush=True)

                term = msg.get('currentTerm')
                if term is not None and term > self.currentTerm:
                    self.currentTerm = term
                    self.votedFor = None
                    self.status = 'follower'

                if msg['src'] == self.leader:  # TODO added
                    self.last_heartbeat = time.time()

                if msg['dst'] != self.id and msg['dst'] != BROADCAST:
                    print('Sent to the wrong host', flush=True)
                    continue

                if msg['type'] == 'get':
                    if self.redirect(msg):
                        continue
                    self.getRequest(msg)  # will have a MID and a key to be gotten
                elif msg['type'] == 'put':
                    if self.redirect(msg):
                        continue
                    self.setRequest(msg)

                if self.status == 'candidate':
                    if msg['type'] == 'vote':
                        self.num_votes += 1
                        if self.num_votes >= len(self.others) / 2:
                            self.status = 'leader'
                            self.leader = self.id
                            # other leader things
                    elif msg['type'] == 'AppendEntries':
                        if msg['leader'] != self.leader:
                            self.status = 'follower'
                            self.leader = msg['leader']

                if self.status == 'follower':
                    if msg['type'] == 'candidacy':
                        print('considering a vote')
                        self.vote(msg)

            # back to running every tick
            currentTime = time.time()
            if self.status != 'leader' and \
                    currentTime - self.last_heartbeat > self.timeout:
                print(currentTime - self.last_heartbeat)
                self.last_heartbeat = currentTime
                self.timeout = TIMEOUT * (random.random() + 1)  # 1-2 x timeout
                self.elect()
                continue

            if self.status == 'leader' and \
                    currentTime - self.last_heartbeat > HEARTBEAT:
                self.last_heartbeat = currentTime
                self.send_args(BROADCAST, 'AppendEntries', None, self.currentTerm, None)  # Heartbeat


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
