#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random, secrets

# secrets.token_hex(16)
BROADCAST = "FFFF"
TIMEOUT = .25
HEARTBEAT = TIMEOUT / 2  # how often heartbeats should be sent

TERM = 0
ENTRY = 1


class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others

        self.last_heartbeat = time.time()  # for the follower's this can be time since having heard
        self.timeout = TIMEOUT * (random.random() + 1)  # recalculate on each timeout

        self.currentTerm = 0
        self.leader = 'FFFF'  # start as unknown
        self.status = 'follower'

        self.votedFor = None
        self.num_votes = set()

        self.log = []  # pair <term, <key, value>> as defined in the constants
        self.data = {}  # the key, value dict that is the store
        self.lastApplied = -1
        self.pending = {}  # 'MID' : {'msg': msg, 'numVotes': set(votes), 'index': the index it is given in the log}
        self.events = []  # time, 'MID' the first will always expire first

        self.commitIndex = -1  # the last know index to be committed to the leader's log (got consensus)
        self.matchIndex = {}

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        print("Replica %s starting up" % self.id, flush=True)
        hello = {"src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello"}
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def send(self, message):
        if message['type'] == 'AppendEntries' and message['dst'] == BROADCAST:
            self.last_heartbeat = time.time()
        #print("Sending message message '%s'" % (message,), flush=True)
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def send_args(self, dst, type, MID, term, value):
        message = {"src": self.id, "dst": dst, "leader": self.leader,
                   "type": type}
        if MID is not None:
            message['MID'] = MID
        if term is not None:
            message['term'] = term
        if value is not None:
            message['value'] = value
        self.send(message)

    def send_append(self, dst, MID, prevLogIndex, prevLogTerm, entries):
        self.send({"src": self.id, "dst": BROADCAST if dst is None else dst, "leader": self.leader,
                   "type": 'AppendEntries', 'MID': MID, 'term': self.currentTerm,
                   'prevLogIndex': prevLogIndex, 'prevLogTerm': prevLogTerm,
                   'entries': entries, 'leaderCommit': self.lastApplied})

    def fail(self, msg):
        self.send_args(msg['src'], 'fail', msg['MID'], None, None)

    def ok(self, msg, value):
        self.send_args(msg['src'], 'ok', msg['MID'], None, value)

    def redirect(self, msg):
        if self.leader is None:
            self.fail(msg)
        if self.leader != self.id:
            self.send_args(msg['src'], 'redirect', msg['MID'], None, None)
            return True
        return False

    def get_request(self, msg):
        contents = self.data.get(msg['key'])
        value = '' if contents is None else contents
        self.ok(msg, value)

    def put_request(self, msg):
        if msg['MID'] in self.pending:
            print('duplicate request')
            return
        if self.status == 'leader':  # no duplicate
            entry = (self.currentTerm, (msg['key'], msg['value']))
            self.send_append(None, msg['MID'], self.prevIndex(), self.prevTerm(), [entry])
            self.log.append(entry)
            self.pending[msg['MID']] = {'msg': msg, 'vote_count': set(), 'index': self.prevIndex()}
            self.events.append((time.time(), msg['MID']))

    def apply_put(self, msg):
        self.apply_log()
        self.commitIndex = self.lastApplied  # only called for the leader
        self.ok(msg, None)

    def apply_log(self):
        self.lastApplied += 1
        key, value = self.log[self.lastApplied][ENTRY]
        self.data[key] = value

    def prevIndex(self):
        return len(self.log) - 1

    def prevTerm(self):
        return self.log[-1][TERM] if len(self.log) > 0 else 0

    def elect(self):
        self.currentTerm += 1
        self.status = 'candidate'
        self.votedFor = self.id
        self.num_votes = set()
        self.send({'src': self.id, 'dst': BROADCAST, 'leader': self.leader, 'type': 'candidacy',
                   'lastTerm': self.prevTerm(), 'lastIndex': self.prevIndex(), 'term': self.currentTerm})

    def vote(self, msg):
        if msg['term'] < self.currentTerm:
            return  # False
        if self.votedFor is None or self.votedFor == msg['src']:
            if msg['lastTerm'] >= self.prevTerm() and msg['lastIndex'] >= self.prevIndex():
                self.votedFor = msg['src']
                self.send_args(msg['src'], 'vote', None, self.currentTerm, None)
                self.last_heartbeat = time.time()
                return

    def forget(self, MID):
        self.pending.pop(MID)
        for i in range(len(self.events)):  # should be near the front of the list
            if self.events[i][0] == MID:
                self.events.pop(i)
                break
        print("event remained")

    def consider_append(self, msg):
        if len(msg['entries']) == 0:  # if not a heartbeat
            return
        prev_i = msg['prevLogIndex']
        if len(self.log) > prev_i + 1 and self.log[prev_i + 1:] == msg['entries']:
            print('was skipping the application of append since it was already there')
            self.send_args(self.leader, 'agree', msg['MID'], self.currentTerm, self.prevIndex())
            return  # already applied, probably duplicate message
        if prev_i == -1 \
                or (len(self.log) > msg['prevLogIndex']  # if index is in the log
                    and self.log[prev_i][TERM] == msg['prevLogTerm']):
            for i in range(len(self.log) - 1 - prev_i):
                self.log.pop(len(self.log) - 1)
            self.log.extend(msg['entries'])
            self.send_args(self.leader, 'agree', msg['MID'], self.currentTerm, self.prevIndex())
            if msg['leaderCommit'] > self.commitIndex:
                self.commitIndex = min(msg['leaderCommit'], self.prevIndex())
                while self.commitIndex > self.lastApplied:
                    self.apply_log()
        else:
            self.send_args(self.leader, 'induce_me', msg['MID'], None, self.commitIndex)

    def induce(self, msg):
        index = msg['value']
        self.send_append(msg['src'], msg['MID'], index, self.log[index][TERM], self.log[index + 1:])

    def deprecated_induce(self, msg):
        log_len = len(msg['value'])
        for index in range(min(log_len, len(self.log)) - 1, -1, -1):
            if msg['value'][index] == self.log[index]:  # if the value is the same at this index
                if len(self.log) <= index + 1:  # then, if the leader's log is not longer
                    return  # nothing to append: exit
                self.send_append(msg['src'], msg['MID'], index, self.log[index][TERM],
                                 self.log[index + 1:])  # if the leader's log is longer, fill in the follower's log
                return  # we found the common point of agreement and replaced the follower's log accordingly so exit
        # otherwise, no point of agreement, replace follower's log
        self.send_append(msg['src'], msg['MID'], -1, 0, self.log)

    def resolve_log(self):
        print("forgetting: " + str(self.events))
        for n in range(len(self.pending)):
            MID = self.events[0][1]  # [(time, MID)]
            if MID not in self.pending:
                print("event was referring to non-existent pending")
                self.events.pop(0)
            else:
                msg = self.pending[MID]['msg']
                self.forget(MID)
                self.fail(msg)

    def run(self):
        while True:
            ready = select.select([self.socket], [], [], .01)[0]
            if len(ready) == 1:
                data, addr = self.socket.recvfrom(65535)
                msg = json.loads(data.decode('utf-8'))
                #print("Received message '%s'" % (msg,), flush=True)

                term = msg.get('term')
                if term is not None and term > self.currentTerm:
                    self.currentTerm = term
                    self.votedFor = None
                    if self.status == 'leader':
                        self.resolve_log()
                    self.status = 'follower'

                if msg['src'] == self.leader:
                    self.last_heartbeat = time.time()

                if msg['dst'] != self.id and msg['dst'] != BROADCAST:
                    print('Sent to the wrong host', flush=True)
                    continue

                if msg['type'] == 'get':
                    if self.redirect(msg):
                        continue
                    self.get_request(msg)  # will have a MID and a key to be gotten
                elif msg['type'] == 'put':
                    if self.redirect(msg):
                        continue
                    self.put_request(msg)

                if self.status == 'leader':
                    if msg['type'] == 'agree':

                        target = self.pending.get(msg['MID'])
                        if target is not None:
                            # update matchIndex
                            current = self.matchIndex.get(msg['src'])
                            if current is None:
                                current = -1
                            self.matchIndex[msg['src']] = max(target['index'], current)
                            # intuiting votes
                            recheck = set()
                            for MID in self.pending.keys():
                                entry = self.pending[MID]
                                # if there is something pending that is a prerequisite to this vote...
                                if entry['index'] < target['index']:
                                    entry['vote_count'].add(msg['src'])  # consider the follower as having voted for it
                                    recheck.add(MID)
                            for MID in recheck:  # TODO refactor
                                entry = self.pending[MID]
                                if len(entry['vote_count']) > int(len(self.others) / 2):
                                    self.apply_put(entry['msg'])
                                    self.forget(MID)
                            target['vote_count'].add(msg['src'])  # increment the votes on the targeted pending message
                            if len(target['vote_count']) > int(len(self.others) / 2):  # TODO refactor
                                self.apply_put(target['msg'])
                                self.forget(msg['MID'])
                    elif msg['type'] == 'induce_me':
                        self.induce(msg)

                if self.status == 'candidate':
                    if msg['type'] == 'vote' and msg['term'] == self.currentTerm:
                        self.num_votes.add(msg['src'])
                        if len(self.num_votes) >= len(self.others) / 2:
                            self.status = 'leader'
                            self.leader = self.id
                            # other leader things
                    elif msg['type'] == 'AppendEntries':
                        if msg['leader'] != self.leader and msg['term'] >= self.currentTerm:
                            self.status = 'follower'
                            self.leader = msg['leader']

                if self.status == 'follower':
                    if msg['type'] == 'candidacy':
                        self.vote(msg)
                    elif msg['type'] == 'consider':
                        if msg['value']['type'] == 'get':
                            self.get_request(msg['value'])  # will have a MID and a key to be gotten
                        else:
                            self.put_request(msg['value'])
                    elif msg['type'] == 'AppendEntries':
                        if msg['leader'] != self.leader and msg['term'] >= self.currentTerm:
                            self.leader = msg['leader']
                        self.consider_append(msg)

            # back to running every tick
            currentTime = time.time()
            if self.status != 'leader' and \
                    currentTime - self.last_heartbeat > self.timeout:
                self.last_heartbeat = currentTime
                self.timeout = TIMEOUT * (random.random() + 1)  # 1-2 x timeout
                self.elect()
                continue

            if self.status == 'leader':
                if currentTime - self.last_heartbeat > HEARTBEAT:
                    self.last_heartbeat = currentTime
                    self.send_append(None, '', self.prevIndex(), self.prevTerm(), [])
                if len(self.events) > 0 and self.events[0][0] - time.time() > TIMEOUT:
                    print("put timed out")
                    MID = self.events[0][1]
                    msg = self.pending[MID]['msg']
                    self.forget(MID)
                    self.fail(msg)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
